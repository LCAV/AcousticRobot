%!TEX root = report.tex
\newpage
\section{Experimental Setup}

% Router
\subsection{Router}

The Router used is a TP\_LINK TL\_MR3020
up to 150 Mbps 

computer to router: (when connected to internet upload: 45, download: 50)
sending 11MB, 11536384 (test10.zip)
raspberry to router:
1.57 MB/s, (in 7.0s)
computer to router:
1.73 MB/s (in 6.4s)




% Camera
\subsection{Camera Setup}

\paragraph{Hardware} The camera is made of a Raspberry Pi 2 Model B with the corresponding Raspi-Camera module. The OS loaded to the camera is the common Raspian WHEEZY system with a few scripts running on startup in the background. The camera connected is the Raspi-Camera module.

\paragraph{Webcam setup} In order to connect to the LAN on startup, a few lines need to be added in $/etc/network/interfaces$: 

\begin{center}
\begin{minipage}{0.9\linewidth}
\begin{lstlisting}[caption=$/etc/network/interfaces$, label=interfaces, frame=none]
auto lo
iface lo inet loopback

iface eth0 inet static
address 172.16.156.138
netmask 255.255.255.0
gateway 172.16.156.1

auto wlan0
allow-hotplug wlan0
iface wlan0 inet static
address 172.16.156.139
netmask 255.255.255.0
gateway 172.16.156.1
wireless-essid korebot
\end{lstlisting}
\end{minipage}
\end{center}

The camera module comes with an own library with modules for taking single images ($raspistill$) or videos ($raspivid$).
The following lines of code are added in a file $\sim\hspace{-0.5em}/start\_camera.sh$ in order to take pictures at regular intervals and save them to $/tmp/stream$. This is where they will be found by the $mjpg_streamer$ module which sends the images to the corresponding server.

\begin{center}
\begin{minipage}{0.9\linewidth}
\begin{lstlisting}[caption=$\sim\hspace{-0.5em}/start\_camera.sh$, label=startcamera, frame=none]
#!/bin/bash
echo "Start camera stream"

sudo mkdir -p /tmp/stream
sudo chmod 777 /tmp/stream
raspistill -w 1280 -h 720 -q 50 -ex backlight -mm backlit -o /tmp/stream/pic.jpg -tl 100 -t 2147483647 &
LD_LIBRARY_PATH=/usr/local/lib mjpg_streamer -i "input_file.so -f /tmp/stream -n pic.jpg" -o "output_http.so -w /usr/local/www"
\end{lstlisting}
\end{minipage}
\end{center}

Line 6 tells the camera to take a picture of resolution $w \times h = 1280 \times 720$ of quality 50\%, 100\% meaning no compression at all, at a time interval of $tl = 100ms$ until the maximum time of $t = 2147483647ms$ is reached, which is the maximum for a 32-bit signed integer.
Other parameters like the exposure (set to backlit, so that background is enhanced: TRY FIXEDFPS for constant lighting? ), and the metering mode (what is this???) can be set. 
With these settings, the resulting picture size is not more than $N_{pic}=803kB$ (779412). (Apparent size: 786kB)
As this size is much too high, the quality is set down to 10, which is equivalent to a quality of around 85 for most applications. This leads to a size of around 100kB. In addition to that, the thumbnail, which is a bitmap that also takes up unnecessary storage space, is deleted and a final image size of 80kB is obtained.

 $N_{pic}=803kB$ 
qual	size
100	533 kB
50	455 kB
10	74
5	37
png  1549kB
bmp 2773kB
 The network speed that needs to be provided to avoid idle times or image distortion is therefore:

Line 7 starts the mjpg streamer from where the picture has been stored and sends it to the local network. 
\begin{equation}
	S_{network} \geq \frac{N_{pic}}{tl}  = \frac{1.1MB}{0.1s}= \frac{1.05Mbits}{0.1s} = 10.5 Mbps
\end{equation}

The router capacity is ??? which would be 

\paragraph{Button}

A button is added to the camera such that it can be restarted or turned off without logging into the camera. This allows the Raspberry to be turned off correctly even when the network has not be set up properly or the ethernet is not working.
The button is a pull-down resistor, thus the signal at the output goes from 0 to 1 when the button is pressed. An interrupt is triggered when the button is pressed in which it counts during 6 seconds weather the button is pressed or not at a rate of 1s. For robustness, a total of 3 signals is sufficient for the system to shut down. If less than 3 signals are registered during the 6 seconds, the system reboots. 

\begin{center}
\begin{minipage}{0.9\linewidth}
\begin{lstlisting}[caption=$\sim\hspace{-0.5em}/switchoff.sh$, label=switchoff, language=Python, frame=none]
#-*- coding: utf8 -*-
import RPi.GPIO as GPIO
import os
import time
#set up GPIO using BCM numbering
GPIO.setmode(GPIO.BCM)
GPIO.setup(10,GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

#function called on pin interrupt
def button_triggered(channel):
        counter = 0
        counter_on = 0
        while (counter <= 6):
                time.sleep(1)
                counter+=1
                if (GPIO.input(10)):
                        counter_on+=1
                if (counter_on >= 3):
                        break

        if (counter_on >= 3):
                print("switchoff.py: Raspberry shutting down now")
                os.system("sudo halt")
        elif (counter_on < 3):
                print("switchoff.py: Rapsberry is going to reboot now")
                os.system("sudo reboot")
#setup pin interrupt
GPIO.add_event_detect(10,GPIO.RISING,callback=button_triggered,bouncetime=300)

#wait forever
while True:
        time.sleep(0.001)

GPIO.cleanup()
\end{lstlisting}
\end{minipage}
\end{center}

\paragraph{Setup}

Both scripts above need to be started on startup of the camera. Therefore, the following lines are put in the file /etc/rc.local:
\begin{center}
\begin{minipage}{0.9\linewidth}
\begin{lstlisting}[caption=$/etc/rc.local$, label=local, frame=none]
#Auto start camera
sudo /home/pi/start_camera.sh &
#Auto start shutdown
sudo python /home/pi/switchoff.py &
\end{lstlisting}
\end{minipage}
\end{center}


picture quality and compression:
\url{www.raspberrypi.org/forum/viewtopic.php?f=43&t=73174&p=527300#p527300}
wget:
\url{https://www.maketecheasier.com/test-internet-connection-speed-from-terminal/}
speedtest:
http://www.speedtest.net/

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "report"
%%% End:
